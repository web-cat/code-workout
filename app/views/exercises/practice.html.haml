= render partial: 'layouts/breadcrumb'
- if @user_time_limit && (@workout_score.created_at + @user_time_limit.minutes) - Time.zone.now > 0
  - user_deadline = @workout_score.created_at + @user_time_limit.minutes
  - user_deadline = user_deadline.to_s
  - user_deadline = user_deadline.split(" ")[0] + "T" + user_deadline.split(" ")[1]
  = javascript_include_tag("timeout")
- else
  - user_deadline = " "
= javascript_include_tag("practice")
.col-md-7
  = semantic_form_for @exercise_version,
    url: (@workout_offering ? organization_workout_offering_exercise_evaluate_path(id: @exercise_version.exercise.id,
      course_id: @workout_offering.course_offering.course.slug,
      organization_id: @workout_offering.course_offering.course.organization.slug,
      term_id: @workout_offering.course_offering.term.slug,
      workout_offering_id: @workout_offering.id) : exercise_evaluate_path(@exercise_version.exercise,
    exercise_version_id: @exercise_version.id,
    feedback_return: true)), remote: true do |f|
    = f.semantic_errors
    %h1= @exercise.display_name
    - if @user_time_limit
      #timer{style: "color: red", data: {deadline: user_deadline} }
    - if @exercise_version.stem
      = markdown @exercise_version.stem.preamble
    - allow_write = true
    - @exercise_version.prompts.each do |question_prompt|
      - prompt = question_prompt.specific
      / render the prompts if there is still time...
      = markdown prompt.question
      - if @workout_offering.ultimate_deadline >= DateTime.now
        - if prompt.is_mcq?
          - answers = @exercise_version.serve_choice_array(question_prompt)
          - answers.each do |a|
            - a[:answer] = markdown(a[:answer])
          - answer = Choice.new
          - if prompt.allow_multiple
            %h2 Choose ALL that apply:
            .answers
              = f.semantic_fields_for answer do |p|
                = p.input :id,
                  as: :check_boxes,
                  collection: answers,
                  member_value: :id,
                  member_label: :answer,
                  selected: false,
                  label: '&nbsp;'
          - elsif @exercise_version.prompts.count > 1
            %h3 Select only one answer for each of the sub-questions:
            - prior_answer = @attempt && @attempt.prompt_answers.where(prompt: prompt.acting_as).first
            - if prior_answer
              - answer = prior_answer.specific.choices.first || answer
            .answers
              = f.semantic_fields_for answer do |p|
                = p.input :id,
                  as: :radio,
                  input_html: {name: "prompt-" + prompt.id.to_s},
                  collection: answers,
                  member_value: :id,
                  member_label: :answer,
                  label: '&nbsp;'
          - else
            %h3 Select one answer:
            - prior_answer = @attempt && @attempt.prompt_answers.where(prompt: prompt.acting_as).first
            - if prior_answer
              - answer = prior_answer.specific.choices.first || answer
            .answers
              = f.semantic_fields_for answer do |p|
                = p.input :id,
                  as: :radio,
                  collection: answers,
                  member_value: :id,
                  member_label: :answer,
                  label: '&nbsp;'
        - elsif prompt.is_coding?
          - examples = prompt.examples
          - if examples.any?
            %p Examples:
            %pre.examples
              - examples.each do |example|
                = example.display_description
                %br
          - prior_answer = @attempt && @attempt.prompt_answers.where(prompt: prompt.acting_as).first
          - if !prior_answer && @workout_offering.andand.continue_from_workout
            - prior_score = @workout_offering.continue_from_workout.score_for(@student_user)
            - prior_attempt = prior_score.attempt_for(@exercise_version.exercise)
            - prior_answer = prior_attempt && prior_attempt.prompt_answers.where(prompt: prompt.acting_as).first
          - if prior_answer && @workout_offering
            - if !@workout_offering.can_be_practiced_by?(current_user)
              - allow_write = false
          - if allow_write && params[:review_user_id].nil?
            = f.input :answer_code, as: :text, class: 'code',
            input_html: { lang: 'text/x-' + (@exercise.language || 'java').downcase, readonly: true, autofocus: true,
              value: prior_answer ? prior_answer.specific.answer : prompt.prepare_starter_code}
          - else
            %pre{ lang: 'text/x-java' }
              = prior_answer ? prior_answer.specific.answer : prompt.prepare_starter_code

      -else
        / show feedback for the prompt
        .alert.alert-danger This workout is closed and responses are no longer being accepted. The correct answer is displayed below.
        - if prompt.is_coding?
          = f.input :answer_code, as: :text, class: 'code',
          input_html: { lang: 'text/x-' + (@exercise.language || 'java').downcase, readonly: true, autofocus: true,
            value: prompt.feedback}
        -else
          %span
            =prompt.feedback
          
    .actions
      - if @workout_offering.nil? || @workout_offering.can_be_practiced_by?(current_user)
        - if @workout_offering.andand.workout_policy.andand.hide_feedback_before_finish && params[:review_user_id].nil?
          = f.submit 'Save my answer!', class: 'btn btn-primary btn-submit', id: 'primarybtn'
        - elsif allow_write && params[:review_user_id].nil?
          = f.submit 'Check my answer!', class: 'btn btn-primary btn-submit', id: 'primarybtn'
      - if @workout_offering && params[:review_user_id].nil?
        = button_link 'Next exercise',
          organization_workout_offering_practice_path(exercise_id: @workout.next_exercise(@exercise, current_user, nil),
          organization_id: @workout_offering.course_offering.course.organization.slug,
          course_id: @workout_offering.course_offering.course.slug,
          term_id: @workout_offering.course_offering.term.slug,
          id: @workout_offering.id),
          class: 'btn btn-next', id: 'nextbtn'
      - elsif @workout && params[:review_user_id].nil?
        = button_link 'Next exercise',
          exercise_practice_path(@workout.next_exercise(@exercise, current_user, @workout_score), workout_id: @workout.id),
          class: 'btn btn-next', id: 'nextbtn'

    - if @workout.nil?
      %br
      = link_to "Practice a different #{@exercise.language} exercise",     |
        (@exercise.language ?                                              |
        random_exercise_path(language: @exercise.language) :               |
        random_exercise_path)                                              |
.col-md-5
  #saved_assurance
  #previous_answer.previous_answer
  - if @attempt
    #exercisefeedback
      = render partial: 'sse/ajax_feedback'
  - else
    #exercisefeedback{style: 'display: none;'}
